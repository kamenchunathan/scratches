// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::non_canonical_partial_ord_impl)]

use std::marker::PhantomData;

use roc_std::roc_refcounted_noop_impl;
use roc_std::RocBox;
use roc_std::RocList;
use roc_std::RocRefcounted;

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(transparent)]
pub struct Event {
    pub r#type: roc_std::RocStr,
}

impl roc_std::RocRefcounted for Event {
    fn inc(&mut self) {
        self.r#type.inc();
    }
    fn dec(&mut self) {
        self.r#type.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[repr(C)]
#[derive(Debug)]
pub struct ClosureData {
    _data: (),
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ClosureData {
    pub fn force_thunk(&mut self, arg0: Event) -> RocBox<()> {
        extern "C" {
            fn roc__setup_callback_for_host_0_caller(
                arg0: *const Event,
                closure_data: *mut u8,
                output: *mut RocBox<()>,
            );
        }

        let mut output = core::mem::MaybeUninit::uninit();

        unsafe {
            roc__setup_callback_for_host_0_caller(
                &arg0,
                self as *mut _ as *mut u8,
                output.as_mut_ptr(),
            );

            output.assume_init()
        }
    }
}

roc_refcounted_noop_impl!(ClosureData);

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_Attr {
    Color = 0,
    OnEvent = 1,
}

impl core::fmt::Debug for discriminant_Attr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Color => f.write_str("discriminant_Attr::Color"),
            Self::OnEvent => f.write_str("discriminant_Attr::OnEvent"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_Attr);

#[repr(C, align(8))]
pub union union_Attr {
    pub Color: core::mem::ManuallyDrop<roc_std::RocStr>,
    pub OnEvent: core::mem::ManuallyDrop<ClosureData>,
}

impl Attr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Attr {
        unsafe {
            let ptr_self = self as *const _ as *const u8;
            // NOTE: Alignment is assumed to always be 8
            core::mem::transmute::<u8, discriminant_Attr>(*ptr_self.add(Attr::size() - 8))
        }
    }
}

/// Attr is an opaque type whose size is uknown at compile time
#[repr(C)]
pub struct Attr {
    _data: (),
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl Attr {
    pub fn size() -> usize {
        extern "C" {
            #[link_name = "roc__setup_callback_for_host_1_exposed_size"]
            fn caller() -> usize;
        }

        unsafe { caller() }
    }
}

impl core::fmt::Debug for Attr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Attr::*;

        unsafe {
            match self.discriminant() {
                Color => {
                    let field: &roc_std::RocStr = &self.borrow_Color();
                    f.debug_tuple("Attr::Color").field(field).finish()
                }
                OnEvent => {
                    let field: &ClosureData = &self.borrow_OnEvent();
                    f.debug_tuple("Attr::OnEvent").field(field).finish()
                }
            }
        }
    }
}

impl Attr {
    pub fn unwrap_Color(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_Attr::Color);
        let attr = &mut self as *mut _ as *mut union_Attr;
        unsafe { core::mem::ManuallyDrop::take(&mut (*attr).Color) }
    }

    pub fn borrow_Color(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_Attr::Color);
        use core::borrow::Borrow;

        let attr = self as *const _ as *const union_Attr;
        unsafe { (*attr).Color.borrow() }
    }

    pub fn borrow_mut_Color(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_Attr::Color);
        use core::borrow::BorrowMut;
        let attr = self as *mut _ as *mut union_Attr;
        unsafe { (*attr).Color.borrow_mut() }
    }

    pub fn is_Color(&self) -> bool {
        matches!(self.discriminant(), discriminant_Attr::Color)
    }

    pub fn unwrap_OnEvent(mut self) -> ClosureData {
        debug_assert_eq!(self.discriminant(), discriminant_Attr::OnEvent);
        let attr = &mut self as *mut _ as *mut union_Attr;
        unsafe { core::mem::ManuallyDrop::take(&mut (*attr).OnEvent) }
    }

    pub fn borrow_OnEvent(&self) -> &ClosureData {
        debug_assert_eq!(self.discriminant(), discriminant_Attr::OnEvent);
        use core::borrow::Borrow;
        let attr = self as *const _ as *const union_Attr;
        unsafe { (*attr).OnEvent.borrow() }
    }

    pub fn borrow_mut_OnEvent(&mut self) -> &mut ClosureData {
        debug_assert_eq!(self.discriminant(), discriminant_Attr::OnEvent);
        use core::borrow::BorrowMut;
        let attr = self as *mut _ as *mut union_Attr;
        unsafe { (*attr).OnEvent.borrow_mut() }
    }

    pub fn is_OnEvent(&self) -> bool {
        matches!(self.discriminant(), discriminant_Attr::OnEvent)
    }
}

impl Drop for Attr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Attr::Color => unsafe {
                let inner: &mut union_Attr = core::mem::transmute(self);
                core::mem::ManuallyDrop::drop(&mut inner.Color);
            },
            discriminant_Attr::OnEvent => unsafe {
                let inner: &mut union_Attr = core::mem::transmute(self);
                core::mem::ManuallyDrop::drop(&mut inner.OnEvent);
            },
        }
    }
}

impl roc_std::RocRefcounted for Attr {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

pub fn setup_callback_for_host(arg0: i32) -> Attrs {
    extern "C" {
        fn roc__setup_callback_for_host_1_exposed_generic(_: *mut Attrs, _: i32);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__setup_callback_for_host_1_exposed_generic(ret.as_mut_ptr(), arg0);

        ret.assume_init()
    }
}

pub fn handle_callback_for_host(arg0: RocBox<()>) -> () {
    extern "C" {
        fn roc__handle_callback_for_host_1_exposed_generic(_: *mut (), _: RocBox<()>);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__handle_callback_for_host_1_exposed_generic(ret.as_mut_ptr(), arg0);

        ret.assume_init()
    }
}

#[derive(Clone, Default, Debug)]
#[repr(transparent)]
pub struct Attrs(RocList<Attr>);

impl<'a> IntoIterator for &'a Attrs {
    type Item = &'a mut Attr;

    type IntoIter = AttrsIterator<'a>;

    fn into_iter(self) -> Self::IntoIter {
        AttrsIterator {
            current_index: 0,
            list: &self.0,
        }
    }
}

pub struct AttrsIterator<'a> {
    current_index: usize,
    list: &'a RocList<Attr>,
}

impl<'a> Iterator for AttrsIterator<'a> {
    type Item = &'a mut Attr;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current_index >= self.list.len() {
            return None;
        }

        let elements_ptr = self.list.as_ptr() as *mut u8;
        let attr: *mut Attr = unsafe { elements_ptr.add(Attr::size() * self.current_index).cast() };
        self.current_index += 1;

        return Some(unsafe { &mut *attr });
    }
}
