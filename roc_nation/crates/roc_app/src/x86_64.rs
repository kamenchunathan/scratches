// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::non_canonical_partial_ord_impl)]

use roc_std::roc_refcounted_noop_impl;
use roc_std::RocBox;
use roc_std::RocRefcounted;

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(transparent)]
pub struct Event {
    pub r#type: roc_std::RocStr,
}

impl roc_std::RocRefcounted for Event {
    fn inc(&mut self) {
        self.r#type.inc();
    }
    fn dec(&mut self) {
        self.r#type.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(transparent)]
pub struct U1 {
    f0: roc_std::RocStr,
}

impl U1 {
    /// A tag named ``C18_5``, with the given payload.
    pub fn C18_5(f0: roc_std::RocStr) -> Self {
        Self { f0 }
    }

    /// Since `U1` only has one tag (namely, `C18_5`),
    /// convert it to `C18_5`'s payload.
    pub fn into_C18_5(self) -> roc_std::RocStr {
        self.f0
    }

    /// Since `U1` only has one tag (namely, `C18_5`),
    /// convert it to `C18_5`'s payload.
    pub fn as_C18_5(&self) -> &roc_std::RocStr {
        &self.f0
    }
}

impl core::fmt::Debug for U1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("U1::C18_5").field(&self.f0).finish()
    }
}

impl roc_std::RocRefcounted for U1 {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct RocFunction_93(u64);

extern "C" {
    pub fn roc__setup_callback_for_host_0_caller(
        arg0: *const Event,
        closure_data: *const u8,
        output: *mut RocBox<()>,
    );
}

impl RocFunction_93 {
    pub fn force_thunk(mut self, arg0: Event) -> RocBox<()> {
        let mut output = core::mem::MaybeUninit::uninit();

        unsafe {
            roc__setup_callback_for_host_0_caller(
                &arg0,
                &mut self.0 as *const _ as *const u8,
                output.as_mut_ptr(),
            );

            output.assume_init()
        }
    }
}

impl roc_std::RocRefcounted for RocFunction_93 {
    fn inc(&mut self) {
        // unimplemented!();
        // self.0.inc();
    }
    fn dec(&mut self) {
        println!("Bingo");
        // self.0.dec();
        println!("Yellow");
    }
    fn is_refcounted() -> bool {
        false
    }
}

pub fn setup_callback_for_host(arg0: i32) -> roc_std::RocList<()> {
    extern "C" {
        fn roc__setup_callback_for_host_1_exposed_generic(_: *mut roc_std::RocList<()>, _: i32);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__setup_callback_for_host_1_exposed_generic(ret.as_mut_ptr(), arg0);

        ret.assume_init()
    }
}

pub fn handle_callback_for_host(arg0: RocBox<()>) -> () {
    extern "C" {
        fn roc__handle_callback_for_host_1_exposed_generic(_: *mut (), _: RocBox<()>);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__handle_callback_for_host_1_exposed_generic(ret.as_mut_ptr(), arg0);

        ret.assume_init()
    }
}
